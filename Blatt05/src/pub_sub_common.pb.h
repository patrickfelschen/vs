// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: pub_sub_common.proto

#ifndef PROTOBUF_INCLUDED_pub_5fsub_5fcommon_2eproto
#define PROTOBUF_INCLUDED_pub_5fsub_5fcommon_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_pub_5fsub_5fcommon_2eproto 

namespace protobuf_pub_5fsub_5fcommon_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[8];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_pub_5fsub_5fcommon_2eproto
namespace pubsub {
class EmptyMessage;
class EmptyMessageDefaultTypeInternal;
extern EmptyMessageDefaultTypeInternal _EmptyMessage_default_instance_;
class Message;
class MessageDefaultTypeInternal;
extern MessageDefaultTypeInternal _Message_default_instance_;
class PubSubParam;
class PubSubParamDefaultTypeInternal;
extern PubSubParamDefaultTypeInternal _PubSubParam_default_instance_;
class ReturnCode;
class ReturnCodeDefaultTypeInternal;
extern ReturnCodeDefaultTypeInternal _ReturnCode_default_instance_;
class SessionId;
class SessionIdDefaultTypeInternal;
extern SessionIdDefaultTypeInternal _SessionId_default_instance_;
class SubscriberAddress;
class SubscriberAddressDefaultTypeInternal;
extern SubscriberAddressDefaultTypeInternal _SubscriberAddress_default_instance_;
class Topic;
class TopicDefaultTypeInternal;
extern TopicDefaultTypeInternal _Topic_default_instance_;
class UserName;
class UserNameDefaultTypeInternal;
extern UserNameDefaultTypeInternal _UserName_default_instance_;
}  // namespace pubsub
namespace google {
namespace protobuf {
template<> ::pubsub::EmptyMessage* Arena::CreateMaybeMessage<::pubsub::EmptyMessage>(Arena*);
template<> ::pubsub::Message* Arena::CreateMaybeMessage<::pubsub::Message>(Arena*);
template<> ::pubsub::PubSubParam* Arena::CreateMaybeMessage<::pubsub::PubSubParam>(Arena*);
template<> ::pubsub::ReturnCode* Arena::CreateMaybeMessage<::pubsub::ReturnCode>(Arena*);
template<> ::pubsub::SessionId* Arena::CreateMaybeMessage<::pubsub::SessionId>(Arena*);
template<> ::pubsub::SubscriberAddress* Arena::CreateMaybeMessage<::pubsub::SubscriberAddress>(Arena*);
template<> ::pubsub::Topic* Arena::CreateMaybeMessage<::pubsub::Topic>(Arena*);
template<> ::pubsub::UserName* Arena::CreateMaybeMessage<::pubsub::UserName>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace pubsub {

enum ReturnCode_Values {
  ReturnCode_Values_OK = 0,
  ReturnCode_Values_CANNOT_REGISTER = 1,
  ReturnCode_Values_CLIENT_ALREADY_REGISTERED = 2,
  ReturnCode_Values_CANNOT_UNREGISTER = 3,
  ReturnCode_Values_CANNOT_SET_TOPIC = 4,
  ReturnCode_Values_NO_HASH_FOR_SESSION = 5,
  ReturnCode_Values_WRONG_HASH_FOR_SESSION = 6,
  ReturnCode_Values_USER_ALREADY_LOGGED_IN = 7,
  ReturnCode_Values_SESSION_INVALID = 8,
  ReturnCode_Values_UNKNOWN_ERROR = 9,
  ReturnCode_Values_ReturnCode_Values_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  ReturnCode_Values_ReturnCode_Values_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool ReturnCode_Values_IsValid(int value);
const ReturnCode_Values ReturnCode_Values_Values_MIN = ReturnCode_Values_OK;
const ReturnCode_Values ReturnCode_Values_Values_MAX = ReturnCode_Values_UNKNOWN_ERROR;
const int ReturnCode_Values_Values_ARRAYSIZE = ReturnCode_Values_Values_MAX + 1;

const ::google::protobuf::EnumDescriptor* ReturnCode_Values_descriptor();
inline const ::std::string& ReturnCode_Values_Name(ReturnCode_Values value) {
  return ::google::protobuf::internal::NameOfEnum(
    ReturnCode_Values_descriptor(), value);
}
inline bool ReturnCode_Values_Parse(
    const ::std::string& name, ReturnCode_Values* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ReturnCode_Values>(
    ReturnCode_Values_descriptor(), name, value);
}
// ===================================================================

class EmptyMessage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pubsub.EmptyMessage) */ {
 public:
  EmptyMessage();
  virtual ~EmptyMessage();

  EmptyMessage(const EmptyMessage& from);

  inline EmptyMessage& operator=(const EmptyMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EmptyMessage(EmptyMessage&& from) noexcept
    : EmptyMessage() {
    *this = ::std::move(from);
  }

  inline EmptyMessage& operator=(EmptyMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const EmptyMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EmptyMessage* internal_default_instance() {
    return reinterpret_cast<const EmptyMessage*>(
               &_EmptyMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(EmptyMessage* other);
  friend void swap(EmptyMessage& a, EmptyMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EmptyMessage* New() const final {
    return CreateMaybeMessage<EmptyMessage>(NULL);
  }

  EmptyMessage* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<EmptyMessage>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const EmptyMessage& from);
  void MergeFrom(const EmptyMessage& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EmptyMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:pubsub.EmptyMessage)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_pub_5fsub_5fcommon_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Message : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pubsub.Message) */ {
 public:
  Message();
  virtual ~Message();

  Message(const Message& from);

  inline Message& operator=(const Message& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Message(Message&& from) noexcept
    : Message() {
    *this = ::std::move(from);
  }

  inline Message& operator=(Message&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Message& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Message* internal_default_instance() {
    return reinterpret_cast<const Message*>(
               &_Message_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(Message* other);
  friend void swap(Message& a, Message& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Message* New() const final {
    return CreateMaybeMessage<Message>(NULL);
  }

  Message* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Message>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Message& from);
  void MergeFrom(const Message& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Message* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string message = 1;
  void clear_message();
  static const int kMessageFieldNumber = 1;
  const ::std::string& message() const;
  void set_message(const ::std::string& value);
  #if LANG_CXX11
  void set_message(::std::string&& value);
  #endif
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  ::std::string* mutable_message();
  ::std::string* release_message();
  void set_allocated_message(::std::string* message);

  // @@protoc_insertion_point(class_scope:pubsub.Message)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr message_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_pub_5fsub_5fcommon_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Topic : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pubsub.Topic) */ {
 public:
  Topic();
  virtual ~Topic();

  Topic(const Topic& from);

  inline Topic& operator=(const Topic& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Topic(Topic&& from) noexcept
    : Topic() {
    *this = ::std::move(from);
  }

  inline Topic& operator=(Topic&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Topic& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Topic* internal_default_instance() {
    return reinterpret_cast<const Topic*>(
               &_Topic_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(Topic* other);
  friend void swap(Topic& a, Topic& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Topic* New() const final {
    return CreateMaybeMessage<Topic>(NULL);
  }

  Topic* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Topic>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Topic& from);
  void MergeFrom(const Topic& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Topic* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string topic = 1;
  void clear_topic();
  static const int kTopicFieldNumber = 1;
  const ::std::string& topic() const;
  void set_topic(const ::std::string& value);
  #if LANG_CXX11
  void set_topic(::std::string&& value);
  #endif
  void set_topic(const char* value);
  void set_topic(const char* value, size_t size);
  ::std::string* mutable_topic();
  ::std::string* release_topic();
  void set_allocated_topic(::std::string* topic);

  // string passcode = 2;
  void clear_passcode();
  static const int kPasscodeFieldNumber = 2;
  const ::std::string& passcode() const;
  void set_passcode(const ::std::string& value);
  #if LANG_CXX11
  void set_passcode(::std::string&& value);
  #endif
  void set_passcode(const char* value);
  void set_passcode(const char* value, size_t size);
  ::std::string* mutable_passcode();
  ::std::string* release_passcode();
  void set_allocated_passcode(::std::string* passcode);

  // @@protoc_insertion_point(class_scope:pubsub.Topic)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr topic_;
  ::google::protobuf::internal::ArenaStringPtr passcode_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_pub_5fsub_5fcommon_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SubscriberAddress : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pubsub.SubscriberAddress) */ {
 public:
  SubscriberAddress();
  virtual ~SubscriberAddress();

  SubscriberAddress(const SubscriberAddress& from);

  inline SubscriberAddress& operator=(const SubscriberAddress& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SubscriberAddress(SubscriberAddress&& from) noexcept
    : SubscriberAddress() {
    *this = ::std::move(from);
  }

  inline SubscriberAddress& operator=(SubscriberAddress&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SubscriberAddress& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SubscriberAddress* internal_default_instance() {
    return reinterpret_cast<const SubscriberAddress*>(
               &_SubscriberAddress_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(SubscriberAddress* other);
  friend void swap(SubscriberAddress& a, SubscriberAddress& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SubscriberAddress* New() const final {
    return CreateMaybeMessage<SubscriberAddress>(NULL);
  }

  SubscriberAddress* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SubscriberAddress>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SubscriberAddress& from);
  void MergeFrom(const SubscriberAddress& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SubscriberAddress* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string ip_address = 1;
  void clear_ip_address();
  static const int kIpAddressFieldNumber = 1;
  const ::std::string& ip_address() const;
  void set_ip_address(const ::std::string& value);
  #if LANG_CXX11
  void set_ip_address(::std::string&& value);
  #endif
  void set_ip_address(const char* value);
  void set_ip_address(const char* value, size_t size);
  ::std::string* mutable_ip_address();
  ::std::string* release_ip_address();
  void set_allocated_ip_address(::std::string* ip_address);

  // int32 port = 2;
  void clear_port();
  static const int kPortFieldNumber = 2;
  ::google::protobuf::int32 port() const;
  void set_port(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:pubsub.SubscriberAddress)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr ip_address_;
  ::google::protobuf::int32 port_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_pub_5fsub_5fcommon_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UserName : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pubsub.UserName) */ {
 public:
  UserName();
  virtual ~UserName();

  UserName(const UserName& from);

  inline UserName& operator=(const UserName& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UserName(UserName&& from) noexcept
    : UserName() {
    *this = ::std::move(from);
  }

  inline UserName& operator=(UserName&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const UserName& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UserName* internal_default_instance() {
    return reinterpret_cast<const UserName*>(
               &_UserName_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(UserName* other);
  friend void swap(UserName& a, UserName& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UserName* New() const final {
    return CreateMaybeMessage<UserName>(NULL);
  }

  UserName* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<UserName>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const UserName& from);
  void MergeFrom(const UserName& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserName* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:pubsub.UserName)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_pub_5fsub_5fcommon_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SessionId : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pubsub.SessionId) */ {
 public:
  SessionId();
  virtual ~SessionId();

  SessionId(const SessionId& from);

  inline SessionId& operator=(const SessionId& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SessionId(SessionId&& from) noexcept
    : SessionId() {
    *this = ::std::move(from);
  }

  inline SessionId& operator=(SessionId&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SessionId& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SessionId* internal_default_instance() {
    return reinterpret_cast<const SessionId*>(
               &_SessionId_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(SessionId* other);
  friend void swap(SessionId& a, SessionId& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SessionId* New() const final {
    return CreateMaybeMessage<SessionId>(NULL);
  }

  SessionId* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SessionId>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SessionId& from);
  void MergeFrom(const SessionId& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SessionId* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:pubsub.SessionId)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_pub_5fsub_5fcommon_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PubSubParam : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pubsub.PubSubParam) */ {
 public:
  PubSubParam();
  virtual ~PubSubParam();

  PubSubParam(const PubSubParam& from);

  inline PubSubParam& operator=(const PubSubParam& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PubSubParam(PubSubParam&& from) noexcept
    : PubSubParam() {
    *this = ::std::move(from);
  }

  inline PubSubParam& operator=(PubSubParam&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const PubSubParam& default_instance();

  enum ParamCase {
    kOptMessage = 1,
    kOptTopic = 2,
    kOptAddress = 3,
    kVoid = 4,
    PARAM_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PubSubParam* internal_default_instance() {
    return reinterpret_cast<const PubSubParam*>(
               &_PubSubParam_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(PubSubParam* other);
  friend void swap(PubSubParam& a, PubSubParam& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PubSubParam* New() const final {
    return CreateMaybeMessage<PubSubParam>(NULL);
  }

  PubSubParam* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PubSubParam>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PubSubParam& from);
  void MergeFrom(const PubSubParam& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PubSubParam* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string hash_string = 6;
  void clear_hash_string();
  static const int kHashStringFieldNumber = 6;
  const ::std::string& hash_string() const;
  void set_hash_string(const ::std::string& value);
  #if LANG_CXX11
  void set_hash_string(::std::string&& value);
  #endif
  void set_hash_string(const char* value);
  void set_hash_string(const char* value, size_t size);
  ::std::string* mutable_hash_string();
  ::std::string* release_hash_string();
  void set_allocated_hash_string(::std::string* hash_string);

  // .pubsub.SessionId sid = 5;
  bool has_sid() const;
  void clear_sid();
  static const int kSidFieldNumber = 5;
  private:
  const ::pubsub::SessionId& _internal_sid() const;
  public:
  const ::pubsub::SessionId& sid() const;
  ::pubsub::SessionId* release_sid();
  ::pubsub::SessionId* mutable_sid();
  void set_allocated_sid(::pubsub::SessionId* sid);

  // .pubsub.Message optMessage = 1;
  bool has_optmessage() const;
  void clear_optmessage();
  static const int kOptMessageFieldNumber = 1;
  private:
  const ::pubsub::Message& _internal_optmessage() const;
  public:
  const ::pubsub::Message& optmessage() const;
  ::pubsub::Message* release_optmessage();
  ::pubsub::Message* mutable_optmessage();
  void set_allocated_optmessage(::pubsub::Message* optmessage);

  // .pubsub.Topic optTopic = 2;
  bool has_opttopic() const;
  void clear_opttopic();
  static const int kOptTopicFieldNumber = 2;
  private:
  const ::pubsub::Topic& _internal_opttopic() const;
  public:
  const ::pubsub::Topic& opttopic() const;
  ::pubsub::Topic* release_opttopic();
  ::pubsub::Topic* mutable_opttopic();
  void set_allocated_opttopic(::pubsub::Topic* opttopic);

  // .pubsub.SubscriberAddress optAddress = 3;
  bool has_optaddress() const;
  void clear_optaddress();
  static const int kOptAddressFieldNumber = 3;
  private:
  const ::pubsub::SubscriberAddress& _internal_optaddress() const;
  public:
  const ::pubsub::SubscriberAddress& optaddress() const;
  ::pubsub::SubscriberAddress* release_optaddress();
  ::pubsub::SubscriberAddress* mutable_optaddress();
  void set_allocated_optaddress(::pubsub::SubscriberAddress* optaddress);

  // .pubsub.EmptyMessage void = 4;
  bool has_void_() const;
  void clear_void_();
  static const int kVoidFieldNumber = 4;
  private:
  const ::pubsub::EmptyMessage& _internal_void_() const;
  public:
  const ::pubsub::EmptyMessage& void_() const;
  ::pubsub::EmptyMessage* release_void_();
  ::pubsub::EmptyMessage* mutable_void_();
  void set_allocated_void_(::pubsub::EmptyMessage* void_);

  void clear_param();
  ParamCase param_case() const;
  // @@protoc_insertion_point(class_scope:pubsub.PubSubParam)
 private:
  void set_has_optmessage();
  void set_has_opttopic();
  void set_has_optaddress();
  void set_has_void_();

  inline bool has_param() const;
  inline void clear_has_param();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr hash_string_;
  ::pubsub::SessionId* sid_;
  union ParamUnion {
    ParamUnion() {}
    ::pubsub::Message* optmessage_;
    ::pubsub::Topic* opttopic_;
    ::pubsub::SubscriberAddress* optaddress_;
    ::pubsub::EmptyMessage* void__;
  } param_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_pub_5fsub_5fcommon_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ReturnCode : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pubsub.ReturnCode) */ {
 public:
  ReturnCode();
  virtual ~ReturnCode();

  ReturnCode(const ReturnCode& from);

  inline ReturnCode& operator=(const ReturnCode& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ReturnCode(ReturnCode&& from) noexcept
    : ReturnCode() {
    *this = ::std::move(from);
  }

  inline ReturnCode& operator=(ReturnCode&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ReturnCode& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReturnCode* internal_default_instance() {
    return reinterpret_cast<const ReturnCode*>(
               &_ReturnCode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(ReturnCode* other);
  friend void swap(ReturnCode& a, ReturnCode& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ReturnCode* New() const final {
    return CreateMaybeMessage<ReturnCode>(NULL);
  }

  ReturnCode* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ReturnCode>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ReturnCode& from);
  void MergeFrom(const ReturnCode& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReturnCode* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ReturnCode_Values Values;
  static const Values OK =
    ReturnCode_Values_OK;
  static const Values CANNOT_REGISTER =
    ReturnCode_Values_CANNOT_REGISTER;
  static const Values CLIENT_ALREADY_REGISTERED =
    ReturnCode_Values_CLIENT_ALREADY_REGISTERED;
  static const Values CANNOT_UNREGISTER =
    ReturnCode_Values_CANNOT_UNREGISTER;
  static const Values CANNOT_SET_TOPIC =
    ReturnCode_Values_CANNOT_SET_TOPIC;
  static const Values NO_HASH_FOR_SESSION =
    ReturnCode_Values_NO_HASH_FOR_SESSION;
  static const Values WRONG_HASH_FOR_SESSION =
    ReturnCode_Values_WRONG_HASH_FOR_SESSION;
  static const Values USER_ALREADY_LOGGED_IN =
    ReturnCode_Values_USER_ALREADY_LOGGED_IN;
  static const Values SESSION_INVALID =
    ReturnCode_Values_SESSION_INVALID;
  static const Values UNKNOWN_ERROR =
    ReturnCode_Values_UNKNOWN_ERROR;
  static inline bool Values_IsValid(int value) {
    return ReturnCode_Values_IsValid(value);
  }
  static const Values Values_MIN =
    ReturnCode_Values_Values_MIN;
  static const Values Values_MAX =
    ReturnCode_Values_Values_MAX;
  static const int Values_ARRAYSIZE =
    ReturnCode_Values_Values_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Values_descriptor() {
    return ReturnCode_Values_descriptor();
  }
  static inline const ::std::string& Values_Name(Values value) {
    return ReturnCode_Values_Name(value);
  }
  static inline bool Values_Parse(const ::std::string& name,
      Values* value) {
    return ReturnCode_Values_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // .pubsub.ReturnCode.Values value = 1;
  void clear_value();
  static const int kValueFieldNumber = 1;
  ::pubsub::ReturnCode_Values value() const;
  void set_value(::pubsub::ReturnCode_Values value);

  // @@protoc_insertion_point(class_scope:pubsub.ReturnCode)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  int value_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_pub_5fsub_5fcommon_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// EmptyMessage

// -------------------------------------------------------------------

// Message

// string message = 1;
inline void Message::clear_message() {
  message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Message::message() const {
  // @@protoc_insertion_point(field_get:pubsub.Message.message)
  return message_.GetNoArena();
}
inline void Message::set_message(const ::std::string& value) {
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:pubsub.Message.message)
}
#if LANG_CXX11
inline void Message::set_message(::std::string&& value) {
  
  message_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:pubsub.Message.message)
}
#endif
inline void Message::set_message(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:pubsub.Message.message)
}
inline void Message::set_message(const char* value, size_t size) {
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:pubsub.Message.message)
}
inline ::std::string* Message::mutable_message() {
  
  // @@protoc_insertion_point(field_mutable:pubsub.Message.message)
  return message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Message::release_message() {
  // @@protoc_insertion_point(field_release:pubsub.Message.message)
  
  return message_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Message::set_allocated_message(::std::string* message) {
  if (message != NULL) {
    
  } else {
    
  }
  message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message);
  // @@protoc_insertion_point(field_set_allocated:pubsub.Message.message)
}

// -------------------------------------------------------------------

// Topic

// string topic = 1;
inline void Topic::clear_topic() {
  topic_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Topic::topic() const {
  // @@protoc_insertion_point(field_get:pubsub.Topic.topic)
  return topic_.GetNoArena();
}
inline void Topic::set_topic(const ::std::string& value) {
  
  topic_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:pubsub.Topic.topic)
}
#if LANG_CXX11
inline void Topic::set_topic(::std::string&& value) {
  
  topic_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:pubsub.Topic.topic)
}
#endif
inline void Topic::set_topic(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  topic_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:pubsub.Topic.topic)
}
inline void Topic::set_topic(const char* value, size_t size) {
  
  topic_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:pubsub.Topic.topic)
}
inline ::std::string* Topic::mutable_topic() {
  
  // @@protoc_insertion_point(field_mutable:pubsub.Topic.topic)
  return topic_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Topic::release_topic() {
  // @@protoc_insertion_point(field_release:pubsub.Topic.topic)
  
  return topic_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Topic::set_allocated_topic(::std::string* topic) {
  if (topic != NULL) {
    
  } else {
    
  }
  topic_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), topic);
  // @@protoc_insertion_point(field_set_allocated:pubsub.Topic.topic)
}

// string passcode = 2;
inline void Topic::clear_passcode() {
  passcode_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Topic::passcode() const {
  // @@protoc_insertion_point(field_get:pubsub.Topic.passcode)
  return passcode_.GetNoArena();
}
inline void Topic::set_passcode(const ::std::string& value) {
  
  passcode_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:pubsub.Topic.passcode)
}
#if LANG_CXX11
inline void Topic::set_passcode(::std::string&& value) {
  
  passcode_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:pubsub.Topic.passcode)
}
#endif
inline void Topic::set_passcode(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  passcode_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:pubsub.Topic.passcode)
}
inline void Topic::set_passcode(const char* value, size_t size) {
  
  passcode_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:pubsub.Topic.passcode)
}
inline ::std::string* Topic::mutable_passcode() {
  
  // @@protoc_insertion_point(field_mutable:pubsub.Topic.passcode)
  return passcode_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Topic::release_passcode() {
  // @@protoc_insertion_point(field_release:pubsub.Topic.passcode)
  
  return passcode_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Topic::set_allocated_passcode(::std::string* passcode) {
  if (passcode != NULL) {
    
  } else {
    
  }
  passcode_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), passcode);
  // @@protoc_insertion_point(field_set_allocated:pubsub.Topic.passcode)
}

// -------------------------------------------------------------------

// SubscriberAddress

// string ip_address = 1;
inline void SubscriberAddress::clear_ip_address() {
  ip_address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SubscriberAddress::ip_address() const {
  // @@protoc_insertion_point(field_get:pubsub.SubscriberAddress.ip_address)
  return ip_address_.GetNoArena();
}
inline void SubscriberAddress::set_ip_address(const ::std::string& value) {
  
  ip_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:pubsub.SubscriberAddress.ip_address)
}
#if LANG_CXX11
inline void SubscriberAddress::set_ip_address(::std::string&& value) {
  
  ip_address_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:pubsub.SubscriberAddress.ip_address)
}
#endif
inline void SubscriberAddress::set_ip_address(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  ip_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:pubsub.SubscriberAddress.ip_address)
}
inline void SubscriberAddress::set_ip_address(const char* value, size_t size) {
  
  ip_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:pubsub.SubscriberAddress.ip_address)
}
inline ::std::string* SubscriberAddress::mutable_ip_address() {
  
  // @@protoc_insertion_point(field_mutable:pubsub.SubscriberAddress.ip_address)
  return ip_address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SubscriberAddress::release_ip_address() {
  // @@protoc_insertion_point(field_release:pubsub.SubscriberAddress.ip_address)
  
  return ip_address_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SubscriberAddress::set_allocated_ip_address(::std::string* ip_address) {
  if (ip_address != NULL) {
    
  } else {
    
  }
  ip_address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ip_address);
  // @@protoc_insertion_point(field_set_allocated:pubsub.SubscriberAddress.ip_address)
}

// int32 port = 2;
inline void SubscriberAddress::clear_port() {
  port_ = 0;
}
inline ::google::protobuf::int32 SubscriberAddress::port() const {
  // @@protoc_insertion_point(field_get:pubsub.SubscriberAddress.port)
  return port_;
}
inline void SubscriberAddress::set_port(::google::protobuf::int32 value) {
  
  port_ = value;
  // @@protoc_insertion_point(field_set:pubsub.SubscriberAddress.port)
}

// -------------------------------------------------------------------

// UserName

// string name = 1;
inline void UserName::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& UserName::name() const {
  // @@protoc_insertion_point(field_get:pubsub.UserName.name)
  return name_.GetNoArena();
}
inline void UserName::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:pubsub.UserName.name)
}
#if LANG_CXX11
inline void UserName::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:pubsub.UserName.name)
}
#endif
inline void UserName::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:pubsub.UserName.name)
}
inline void UserName::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:pubsub.UserName.name)
}
inline ::std::string* UserName::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:pubsub.UserName.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UserName::release_name() {
  // @@protoc_insertion_point(field_release:pubsub.UserName.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UserName::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:pubsub.UserName.name)
}

// -------------------------------------------------------------------

// SessionId

// int32 id = 1;
inline void SessionId::clear_id() {
  id_ = 0;
}
inline ::google::protobuf::int32 SessionId::id() const {
  // @@protoc_insertion_point(field_get:pubsub.SessionId.id)
  return id_;
}
inline void SessionId::set_id(::google::protobuf::int32 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:pubsub.SessionId.id)
}

// -------------------------------------------------------------------

// PubSubParam

// .pubsub.Message optMessage = 1;
inline bool PubSubParam::has_optmessage() const {
  return param_case() == kOptMessage;
}
inline void PubSubParam::set_has_optmessage() {
  _oneof_case_[0] = kOptMessage;
}
inline void PubSubParam::clear_optmessage() {
  if (has_optmessage()) {
    delete param_.optmessage_;
    clear_has_param();
  }
}
inline const ::pubsub::Message& PubSubParam::_internal_optmessage() const {
  return *param_.optmessage_;
}
inline ::pubsub::Message* PubSubParam::release_optmessage() {
  // @@protoc_insertion_point(field_release:pubsub.PubSubParam.optMessage)
  if (has_optmessage()) {
    clear_has_param();
      ::pubsub::Message* temp = param_.optmessage_;
    param_.optmessage_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::pubsub::Message& PubSubParam::optmessage() const {
  // @@protoc_insertion_point(field_get:pubsub.PubSubParam.optMessage)
  return has_optmessage()
      ? *param_.optmessage_
      : *reinterpret_cast< ::pubsub::Message*>(&::pubsub::_Message_default_instance_);
}
inline ::pubsub::Message* PubSubParam::mutable_optmessage() {
  if (!has_optmessage()) {
    clear_param();
    set_has_optmessage();
    param_.optmessage_ = CreateMaybeMessage< ::pubsub::Message >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:pubsub.PubSubParam.optMessage)
  return param_.optmessage_;
}

// .pubsub.Topic optTopic = 2;
inline bool PubSubParam::has_opttopic() const {
  return param_case() == kOptTopic;
}
inline void PubSubParam::set_has_opttopic() {
  _oneof_case_[0] = kOptTopic;
}
inline void PubSubParam::clear_opttopic() {
  if (has_opttopic()) {
    delete param_.opttopic_;
    clear_has_param();
  }
}
inline const ::pubsub::Topic& PubSubParam::_internal_opttopic() const {
  return *param_.opttopic_;
}
inline ::pubsub::Topic* PubSubParam::release_opttopic() {
  // @@protoc_insertion_point(field_release:pubsub.PubSubParam.optTopic)
  if (has_opttopic()) {
    clear_has_param();
      ::pubsub::Topic* temp = param_.opttopic_;
    param_.opttopic_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::pubsub::Topic& PubSubParam::opttopic() const {
  // @@protoc_insertion_point(field_get:pubsub.PubSubParam.optTopic)
  return has_opttopic()
      ? *param_.opttopic_
      : *reinterpret_cast< ::pubsub::Topic*>(&::pubsub::_Topic_default_instance_);
}
inline ::pubsub::Topic* PubSubParam::mutable_opttopic() {
  if (!has_opttopic()) {
    clear_param();
    set_has_opttopic();
    param_.opttopic_ = CreateMaybeMessage< ::pubsub::Topic >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:pubsub.PubSubParam.optTopic)
  return param_.opttopic_;
}

// .pubsub.SubscriberAddress optAddress = 3;
inline bool PubSubParam::has_optaddress() const {
  return param_case() == kOptAddress;
}
inline void PubSubParam::set_has_optaddress() {
  _oneof_case_[0] = kOptAddress;
}
inline void PubSubParam::clear_optaddress() {
  if (has_optaddress()) {
    delete param_.optaddress_;
    clear_has_param();
  }
}
inline const ::pubsub::SubscriberAddress& PubSubParam::_internal_optaddress() const {
  return *param_.optaddress_;
}
inline ::pubsub::SubscriberAddress* PubSubParam::release_optaddress() {
  // @@protoc_insertion_point(field_release:pubsub.PubSubParam.optAddress)
  if (has_optaddress()) {
    clear_has_param();
      ::pubsub::SubscriberAddress* temp = param_.optaddress_;
    param_.optaddress_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::pubsub::SubscriberAddress& PubSubParam::optaddress() const {
  // @@protoc_insertion_point(field_get:pubsub.PubSubParam.optAddress)
  return has_optaddress()
      ? *param_.optaddress_
      : *reinterpret_cast< ::pubsub::SubscriberAddress*>(&::pubsub::_SubscriberAddress_default_instance_);
}
inline ::pubsub::SubscriberAddress* PubSubParam::mutable_optaddress() {
  if (!has_optaddress()) {
    clear_param();
    set_has_optaddress();
    param_.optaddress_ = CreateMaybeMessage< ::pubsub::SubscriberAddress >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:pubsub.PubSubParam.optAddress)
  return param_.optaddress_;
}

// .pubsub.EmptyMessage void = 4;
inline bool PubSubParam::has_void_() const {
  return param_case() == kVoid;
}
inline void PubSubParam::set_has_void_() {
  _oneof_case_[0] = kVoid;
}
inline void PubSubParam::clear_void_() {
  if (has_void_()) {
    delete param_.void__;
    clear_has_param();
  }
}
inline const ::pubsub::EmptyMessage& PubSubParam::_internal_void_() const {
  return *param_.void__;
}
inline ::pubsub::EmptyMessage* PubSubParam::release_void_() {
  // @@protoc_insertion_point(field_release:pubsub.PubSubParam.void)
  if (has_void_()) {
    clear_has_param();
      ::pubsub::EmptyMessage* temp = param_.void__;
    param_.void__ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::pubsub::EmptyMessage& PubSubParam::void_() const {
  // @@protoc_insertion_point(field_get:pubsub.PubSubParam.void)
  return has_void_()
      ? *param_.void__
      : *reinterpret_cast< ::pubsub::EmptyMessage*>(&::pubsub::_EmptyMessage_default_instance_);
}
inline ::pubsub::EmptyMessage* PubSubParam::mutable_void_() {
  if (!has_void_()) {
    clear_param();
    set_has_void_();
    param_.void__ = CreateMaybeMessage< ::pubsub::EmptyMessage >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:pubsub.PubSubParam.void)
  return param_.void__;
}

// .pubsub.SessionId sid = 5;
inline bool PubSubParam::has_sid() const {
  return this != internal_default_instance() && sid_ != NULL;
}
inline void PubSubParam::clear_sid() {
  if (GetArenaNoVirtual() == NULL && sid_ != NULL) {
    delete sid_;
  }
  sid_ = NULL;
}
inline const ::pubsub::SessionId& PubSubParam::_internal_sid() const {
  return *sid_;
}
inline const ::pubsub::SessionId& PubSubParam::sid() const {
  const ::pubsub::SessionId* p = sid_;
  // @@protoc_insertion_point(field_get:pubsub.PubSubParam.sid)
  return p != NULL ? *p : *reinterpret_cast<const ::pubsub::SessionId*>(
      &::pubsub::_SessionId_default_instance_);
}
inline ::pubsub::SessionId* PubSubParam::release_sid() {
  // @@protoc_insertion_point(field_release:pubsub.PubSubParam.sid)
  
  ::pubsub::SessionId* temp = sid_;
  sid_ = NULL;
  return temp;
}
inline ::pubsub::SessionId* PubSubParam::mutable_sid() {
  
  if (sid_ == NULL) {
    auto* p = CreateMaybeMessage<::pubsub::SessionId>(GetArenaNoVirtual());
    sid_ = p;
  }
  // @@protoc_insertion_point(field_mutable:pubsub.PubSubParam.sid)
  return sid_;
}
inline void PubSubParam::set_allocated_sid(::pubsub::SessionId* sid) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete sid_;
  }
  if (sid) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      sid = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, sid, submessage_arena);
    }
    
  } else {
    
  }
  sid_ = sid;
  // @@protoc_insertion_point(field_set_allocated:pubsub.PubSubParam.sid)
}

// string hash_string = 6;
inline void PubSubParam::clear_hash_string() {
  hash_string_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PubSubParam::hash_string() const {
  // @@protoc_insertion_point(field_get:pubsub.PubSubParam.hash_string)
  return hash_string_.GetNoArena();
}
inline void PubSubParam::set_hash_string(const ::std::string& value) {
  
  hash_string_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:pubsub.PubSubParam.hash_string)
}
#if LANG_CXX11
inline void PubSubParam::set_hash_string(::std::string&& value) {
  
  hash_string_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:pubsub.PubSubParam.hash_string)
}
#endif
inline void PubSubParam::set_hash_string(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  hash_string_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:pubsub.PubSubParam.hash_string)
}
inline void PubSubParam::set_hash_string(const char* value, size_t size) {
  
  hash_string_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:pubsub.PubSubParam.hash_string)
}
inline ::std::string* PubSubParam::mutable_hash_string() {
  
  // @@protoc_insertion_point(field_mutable:pubsub.PubSubParam.hash_string)
  return hash_string_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PubSubParam::release_hash_string() {
  // @@protoc_insertion_point(field_release:pubsub.PubSubParam.hash_string)
  
  return hash_string_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PubSubParam::set_allocated_hash_string(::std::string* hash_string) {
  if (hash_string != NULL) {
    
  } else {
    
  }
  hash_string_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hash_string);
  // @@protoc_insertion_point(field_set_allocated:pubsub.PubSubParam.hash_string)
}

inline bool PubSubParam::has_param() const {
  return param_case() != PARAM_NOT_SET;
}
inline void PubSubParam::clear_has_param() {
  _oneof_case_[0] = PARAM_NOT_SET;
}
inline PubSubParam::ParamCase PubSubParam::param_case() const {
  return PubSubParam::ParamCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// ReturnCode

// .pubsub.ReturnCode.Values value = 1;
inline void ReturnCode::clear_value() {
  value_ = 0;
}
inline ::pubsub::ReturnCode_Values ReturnCode::value() const {
  // @@protoc_insertion_point(field_get:pubsub.ReturnCode.value)
  return static_cast< ::pubsub::ReturnCode_Values >(value_);
}
inline void ReturnCode::set_value(::pubsub::ReturnCode_Values value) {
  
  value_ = value;
  // @@protoc_insertion_point(field_set:pubsub.ReturnCode.value)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace pubsub

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::pubsub::ReturnCode_Values> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pubsub::ReturnCode_Values>() {
  return ::pubsub::ReturnCode_Values_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_pub_5fsub_5fcommon_2eproto
